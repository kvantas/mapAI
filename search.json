[{"path":"https://kvantas.github.io/mapAI/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 mapAI authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":[]},{"path":"https://kvantas.github.io/mapAI/articles/demo_data.html","id":"generate-and-load-synthetic-data","dir":"Articles","previous_headings":"Positional Correction Workflow","what":"Generate and Load Synthetic Data","title":"Getting Started with mapAI: A Complete Workflow","text":"First, use create_demo_data() create test case. ’ll choose \"complex\" distortion type represents challenging combination errors. load files R using package’s reading functions.","code":"# Create the shapefile and GCPs CSV in a temporary directory demo_files <- create_demo_data(type = \"complex\", seed = 123) #>    -> Homologous points saved to: /tmp/RtmpKAUmwM/demo_gcps.csv #>    -> Distorted map saved to: /tmp/RtmpKAUmwM/demo_map.shp  # Load the GCPs (homologous points) from the demo file gcp_data <- read_gcps(gcp_path = demo_files$gcp_path, crs = 3857)  # Load the vector map that needs correction from the demo file map_to_correct <- read_map(shp_path = demo_files$shp_path, crs = 3857)"},{"path":"https://kvantas.github.io/mapAI/articles/demo_data.html","id":"assess-initial-error-and-train-a-model","dir":"Articles","previous_headings":"Positional Correction Workflow","what":"Assess Initial Error and Train a Model","title":"Getting Started with mapAI: A Complete Workflow","text":"calculate initial 2D Root Mean Squared Error (RMSE) get baseline positional error use cross validation estimate --sample error Generalized Additive Model (gam). GAMs well-suited capturing smooth, non-linear distortions synthetic data.","code":"# Calculate the initial error before correction identity_rmse <- sqrt(mean(gcp_data$dx^2 + gcp_data$dy^2)) print(paste(\"Initial (Identity) 2D RMSE:\", round(identity_rmse, 4))) #> [1] \"Initial (Identity) 2D RMSE: 5.3465\"  # use cross validation to assess a GAM's model accuracy cv_res <- assess_pai_model(gcp_data,\"gam\") print(cv_res) #>   Method ValidationType Mean_RMSE_2D SD_RMSE_2D #> 1    gam         random    0.7495636 0.06099847 # Train the GAM model using our GCP data pai_model_gam <- train_pai_model(gcp_data, method = \"gam\")"},{"path":"https://kvantas.github.io/mapAI/articles/demo_data.html","id":"apply-correction-and-visualize-the-result","dir":"Articles","previous_headings":"Positional Correction Workflow","what":"Apply Correction and Visualize the Result","title":"Getting Started with mapAI: A Complete Workflow","text":"apply trained model map grid visualize result overlaying corrected grid original. plot clearly shows warped grid adjusted back regular shape, demonstrating successful correction.","code":"# Apply the trained model to the full map corrected_map <- apply_pai_model(pai_model = pai_model_gam, map = map_to_correct) #> Applying PAI model to map features... #> Correction complete.  # For easy plotting, add a \"status\" column and combine the maps map_to_correct$status <- \"Original (Distorted)\" corrected_map$status <- \"Corrected\" comparison_data <- rbind(map_to_correct[, \"status\"], corrected_map[, \"status\"])  # Create the final comparison plot ggplot(comparison_data) +   geom_sf(aes(color = status, linetype = status), fill = NA, linewidth = 0.7) +   scale_color_manual(values = c(\"Original (Distorted)\" = \"grey50\", \"Corrected\" = \"red\")) +   scale_linetype_manual(values = c(\"Original (Distorted)\" = \"dashed\", \"Corrected\" = \"solid\")) +   labs(     title = \"Map Correction Comparison\",     subtitle = \"Overlay of the original and corrected map grids\"   ) +   theme_minimal()"},{"path":"https://kvantas.github.io/mapAI/articles/demo_data.html","id":"advanced-distortion-analysis","dir":"Articles","previous_headings":"","what":"Advanced Distortion Analysis","title":"Getting Started with mapAI: A Complete Workflow","text":"Beyond simple correction, mapAI provides powerful tools quantify visualize distortion . useful understanding history map’s creation identifying areas high uncertainty.","code":""},{"path":"https://kvantas.github.io/mapAI/articles/demo_data.html","id":"step-4-run-the-distortion-analysis","dir":"Articles","previous_headings":"Advanced Distortion Analysis","what":"Step 4: Run the Distortion Analysis","title":"Getting Started with mapAI: A Complete Workflow","text":"first create regular grid points analysis. , use analyze_distortion() function trained gam_model calculate detailed distortion metrics point.","code":"# Create a regular grid of points for the analysis analysis_points <- sf::st_make_grid(gcp_data, n = c(25, 25)) %>%   sf::st_centroid() %>%   sf::st_sf()  # Run the analysis distortion_results <- analyze_distortion(pai_model_gam, analysis_points)  # Glimpse the new columns added to our data glimpse(distortion_results) #> Rows: 625 #> Columns: 9 #> $ geometry               <POINT [m]> POINT (1.987481 -1.918547), POINT (6.0986… #> $ a                      <dbl> 1.0201617, 1.0132633, 1.0082489, 1.0056066, 1.0… #> $ b                      <dbl> 0.9378401, 0.9356228, 0.9331371, 0.9299045, 0.9… #> $ area_scale             <dbl> 0.9567486, 0.9480322, 0.9408344, 0.9351181, 0.9… #> $ log2_area_scale        <dbl> -0.06378823, -0.07699201, -0.08798727, -0.09677… #> $ max_shear              <dbl> 2.409636, 2.283177, 2.217313, 2.241536, 2.30422… #> $ max_angular_distortion <dbl> 0.08411216, 0.07969792, 0.07739883, 0.07824438,… #> $ airy_kavrayskiy        <dbl> 0.002258491, 0.002300784, 0.002428281, 0.002656… #> $ theta_a                <dbl> -0.01012249, -4.08984269, -8.30682561, -11.7028…"},{"path":"https://kvantas.github.io/mapAI/articles/demo_data.html","id":"step-5-visualize-distortion-metrics","dir":"Articles","previous_headings":"Advanced Distortion Analysis","what":"Step 5: Visualize Distortion Metrics","title":"Getting Started with mapAI: A Complete Workflow","text":"Now can use plot_distortion_surface() visualize metrics.","code":""},{"path":"https://kvantas.github.io/mapAI/articles/demo_data.html","id":"areal-distortion-log2σ-and-angular-distortion-2ω","dir":"Articles","previous_headings":"Advanced Distortion Analysis > Step 5: Visualize Distortion Metrics","what":"Areal Distortion (log2σ) and Angular Distortion (2Ω)","title":"Getting Started with mapAI: A Complete Workflow","text":"two fundamental distortion metrics. log2_area_scale shows map stretched shrunk, max_angular_distortion_rad shows angles deformed (shear).","code":"# Plot for log2(sigma) - areal distortion plot_area <- plot_distortion_surface(   distortion_results,   metric = \"log2_area_scale\",   diverging = TRUE ) +   labs(title = \"Areal Distortion (log2σ)\") #> Regular grid detected. Creating a surface plot with geom_raster().  # Plot for 2*Omega - angular distortion plot_shear <- plot_distortion_surface(   distortion_results,   metric = \"max_angular_distortion\",   palette = \"magma\" ) +   labs(title = \"Angular Distortion (2Ω)\") #> Regular grid detected. Creating a surface plot with geom_raster().     plot_shear #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. #> Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. plot_area #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. #> Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead."},{"path":"https://kvantas.github.io/mapAI/articles/demo_data.html","id":"airy-kavrayskiy-measure","dir":"Articles","previous_headings":"Advanced Distortion Analysis > Step 5: Visualize Distortion Metrics","what":"Airy-Kavrayskiy Measure","title":"Getting Started with mapAI: A Complete Workflow","text":"combined measure distortion balances areal angular errors. can calculate b values produced analyze_distortion.","code":"# Plot the Airy-Kavrayskiy metric plot_distortion_surface(   distortion_results,   metric = \"airy_kavrayskiy\",   palette = \"cividis\" ) +   labs(title = \"Airy-Kavrayskiy Combined Distortion Measure\") #> Regular grid detected. Creating a surface plot with geom_raster(). #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. #> Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead."},{"path":"https://kvantas.github.io/mapAI/articles/demo_data.html","id":"tissots-indicatrices","dir":"Articles","previous_headings":"Advanced Distortion Analysis > Step 5: Visualize Distortion Metrics","what":"Tissot’s Indicatrices","title":"Getting Started with mapAI: A Complete Workflow","text":"Finally, plot_indicatrices provides richest visualization, showing distortion ellipses . shape, size, orientation ellipse represent local distortion pattern. advanced analysis demonstrates mapAI can used fix historical maps, deeply understand geometric properties.","code":"# Plot the indicatrices at the locations of the analysis points # We use a large scale_factor to make the ellipses clearly visible. plot_indicatrices(   distortion_sf = distortion_results,   scale_factor = 1,   fill_color = \"lightblue\",   border_color = \"black\" ) #> Generating indicatrix polygons at source locations..."},{"path":"https://kvantas.github.io/mapAI/articles/pai_validation.html","id":"load-and-explore-the-package-data","dir":"Articles","previous_headings":"","what":"Load and Explore the Package Data","title":"Comparing PAI Methods and Validation Strategies","text":"mapAI package comes two datasets Kastoria study: parcels: sf object cadastral polygons 1925 map. gcps: sf object homologous points (GCPs) map, including calculated dx dy displacements. Since data already included package, can load directly data() function.","code":"# Load the built-in datasets data(parcels) data(gcps)  # Let's calculate the baseline error of the uncorrected map # This \"Identity RMSE\" is our starting point. identity_rmse <- sqrt(mean(gcps$dx^2 + gcps$dy^2)) print(paste(\"Initial average error (RMSE) of the Kastoria map:\", round(identity_rmse, 2), \"meters\")) #> [1] \"Initial average error (RMSE) of the Kastoria map: 0.69 meters\""},{"path":"https://kvantas.github.io/mapAI/articles/pai_validation.html","id":"comparing-validation-strategies","dir":"Articles","previous_headings":"","what":"Comparing Validation Strategies","title":"Comparing PAI Methods and Validation Strategies","text":"key challenge spatial data science spatial autocorrelation, meaning points closer together likely similar. Standard random k-fold cross-validation (CV) ignores , can lead optimistic misleadingly low error estimates test points might close training points. address , two distinct validation philosophies often considered:","code":""},{"path":"https://kvantas.github.io/mapAI/articles/pai_validation.html","id":"cross-validation-strategies","dir":"Articles","previous_headings":"Comparing Validation Strategies","what":"Cross-Validation Strategies","title":"Comparing PAI Methods and Validation Strategies","text":"Spatial Cross-Validation (SCV) one alternative random CV. creates geographically distinct folds, often using k-means clustering. avoids optimism random CV, can provide pessimistic estimate testing model’s ability extrapolate entirely new areas.","code":""},{"path":"https://kvantas.github.io/mapAI/articles/pai_validation.html","id":"design-based-validation-a-more-robust-assessment","dir":"Articles","previous_headings":"Comparing Validation Strategies","what":"Design-Based Validation: A More Robust Assessment","title":"Comparing PAI Methods and Validation Strategies","text":"importantly, line best practices map accuracy assessment, design-based validation single train/test split often preferred. approach simulates evaluation final model truly independent validation set, offering statistically sound assessment predictive accuracy. package implements via: * Simple random sampling split. * Stratified random sampling, ensures validation set contains representative sample points across full spectrum error magnitudes. offering comprehensive suite methods (random CV, SCV, design-based validation), can move beyond simply comparing traditional CV strategies perform robust assessment model’s predictive accuracy. Let’s compare results methods three models (lm, rf, gam). Comparison Validation Results Now, let’s visualize results make comparison clear.","code":"# Helper function to run validation for all models validate_all_methods <- function(gcp_data, validation_type) {   message(paste(\"\\nRunning\", validation_type, \"cross-validation...\"))      # Validate each model type   lm_results <- assess_pai_model(gcp_data, method = \"lm\",k_folds = 10, seed = 1, validation_type = validation_type)   rf_results <- assess_pai_model(gcp_data, method = \"rf\",k_folds = 10, seed = 1, validation_type = validation_type)   gam_results <- assess_pai_model(gcp_data, method = \"gam\",k_folds = 10, seed = 1, validation_type = validation_type)   hlm_results <- assess_pai_model(gcp_data, method = \"helmert\",k_folds = 10, seed = 1, validation_type = validation_type)      # Combine and return the results   rbind(lm_results, rf_results, gam_results, hlm_results) }  # Run both random and spatial cross-validation random_cv_results <- validate_all_methods(gcps, \"random\") spatial_cv_results <- validate_all_methods(gcps, \"spatial\") stratified_results <- validate_all_methods(gcps, \"stratified\")  # Combine into one table for comparison all_results <- rbind(random_cv_results, spatial_cv_results, stratified_results)  # Print the results table knitr::kable(all_results, caption = \"Comparison of Validation Results\", digits = 2) ggplot(all_results, aes(x = Method, y = Mean_RMSE_2D, fill = ValidationType)) +   geom_col(position = \"dodge\") +   geom_errorbar(     aes(ymin = Mean_RMSE_2D - SD_RMSE_2D, ymax = Mean_RMSE_2D + SD_RMSE_2D),     width = 0.2, position = position_dodge(0.9)   ) +   labs(     title = \"Comparing Validation Results\",     subtitle = \"Note how spatial CV provides a higher error estimate\",     x = \"Correction Model\",     y = \"Mean 2D RMSE (meters)\",     fill = \"Validation Type\"   ) +   theme_minimal()"},{"path":"https://kvantas.github.io/mapAI/articles/pai_validation.html","id":"train-the-final-model-and-analyze-it","dir":"Articles","previous_headings":"","what":"Train the Final Model and Analyze It","title":"Comparing PAI Methods and Validation Strategies","text":"Based validation, choose lm final model train entire set GCPs.","code":"# Train the final model on all available data pai_model <- train_pai_model(gcps, method = \"lm\") #> Training 'lm' model...  # Let's look at the statistical summary of our trained model print(summary(pai_model$model$model_dx)) #>  #> Call: #> stats::lm(formula = formula, data = data) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.27422 -0.18591  0.00183  0.15729  1.18893  #>  #> Coefficients: #>               Estimate Std. Error t value Pr(>|t|)     #> (Intercept) -6.644e+03  7.461e+02  -8.904   <2e-16 *** #> source_x     5.886e-05  1.373e-04   0.429    0.668     #> source_y     1.477e-03  1.663e-04   8.880   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.3619 on 297 degrees of freedom #> Multiple R-squared:  0.2109, Adjusted R-squared:  0.2056  #> F-statistic: 39.68 on 2 and 297 DF,  p-value: 5.333e-16 print(summary(pai_model$model$model_dy)) #>  #> Call: #> stats::lm(formula = formula, data = data) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.22190 -0.22767 -0.03835  0.20294  1.60099  #>  #> Coefficients: #>               Estimate Std. Error t value Pr(>|t|)     #> (Intercept) -6.104e+03  7.848e+02  -7.778 1.22e-13 *** #> source_x    -1.228e-03  1.444e-04  -8.505 9.02e-16 *** #> source_y     1.434e-03  1.749e-04   8.196 7.53e-15 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Residual standard error: 0.3806 on 297 degrees of freedom #> Multiple R-squared:  0.3129, Adjusted R-squared:  0.3083  #> F-statistic: 67.64 on 2 and 297 DF,  p-value: < 2.2e-16"},{"path":"https://kvantas.github.io/mapAI/articles/pai_validation.html","id":"apply-and-visualize-the-final-correction","dir":"Articles","previous_headings":"","what":"Apply and Visualize the Final Correction","title":"Comparing PAI Methods and Validation Strategies","text":"Finally, apply chosen analyzed gam model Kastoria parcels data. plot first five parcels zoom area.  final plot shows tangible result work: corrected parcels shifted slightly reshaped, representing accurate historical reality. vignette demonstrated move basic workflow robust comparative analysis, giving confidence choice model final accuracy.","code":"# Apply the model to the parcel polygons corrected_parcels <- apply_pai_model(pai_model = pai_model, map = parcels) #> Applying PAI model to map features... #> Calculating area of corrected polygons... #> Correction complete.  # Inspect the output - note the new 'area_new' column print(\"Original vs. Corrected Dataframe Head:\") #> [1] \"Original vs. Corrected Dataframe Head:\" head(corrected_parcels) #> Simple feature collection with 6 features and 3 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 268541.9 ymin: 4488641 xmax: 268607.5 ymax: 4488718 #> Projected CRS: GGRS87 / Greek Grid #>      KAK                       geometry        area_old        area_new #> 1 151415 POLYGON ((268546.3 4488664,...  455.2082 [m^2]  455.8884 [m^2] #> 2 151416 POLYGON ((268541.9 4488652,...  259.0621 [m^2]  259.4492 [m^2] #> 3 151419 POLYGON ((268595.9 4488651,...  191.7725 [m^2]  192.0591 [m^2] #> 4 151418 POLYGON ((268583.3 4488669,...  209.8621 [m^2]  210.1757 [m^2] #> 5 151417 POLYGON ((268578.7 4488670,...  188.5859 [m^2]  188.8677 [m^2] #> 6 151412 POLYGON ((268602.3 4488682,... 1352.2642 [m^2] 1354.2848 [m^2]  # Create the final comparison plot ggplot() +   geom_sf(data = parcels[1:5, ], aes(color = \"Original\"), fill = \"grey75\", linetype = \"dashed\") +   geom_sf(data = corrected_parcels[1:5, ], aes(color = \"Corrected\"), fill = NA) +   scale_color_manual(     name = \"Parcel Status\",     values = c(\"Original\" = \"grey25\", \"Corrected\" = \"#e41a1c\")   ) +   labs(     title = \"Positional Correction of 1925 Kastoria Parcels\",     subtitle = \"Overlay of original (dashed) and corrected (solid) polygons\"   ) +     coord_sf(datum = sf::st_crs(2100)) +   theme_minimal()"},{"path":"https://kvantas.github.io/mapAI/articles/swiss_data.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Advanced Analysis with Swiss Data","text":"First, load necessary libraries workflow.","code":"# Load the necessary libraries library(mapAI) library(sf) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(ggplot2) library(patchwork) library(knitr)"},{"path":"https://kvantas.github.io/mapAI/articles/swiss_data.html","id":"initial-data-analysis","dir":"Articles","previous_headings":"","what":"Initial Data Analysis","title":"Advanced Analysis with Swiss Data","text":"begin loading swiss_cps dataset. sf object contains 343 control points source coordinates pre-aligned, can focus residual dx dy errors.  plot shows clear spatial patterns remaining errors, simple linear model fix. confirms need non-linear approach.","code":"# Load the built-in Swiss control points dataset data(swiss_cps)  # Inspect the data structure glimpse(swiss_cps) #> Rows: 343 #> Columns: 8 #> $ Index    <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18… #> $ source_x <dbl> 612293.0, 612225.0, 615470.3, 616339.8, 616927.1, 617571.9, 6… #> $ source_y <dbl> 267353.6, 270412.7, 270195.1, 269367.5, 269507.6, 269273.5, 2… #> $ target_x <dbl> 611375.9, 611573.1, 615840.8, 616129.6, 617031.0, 618168.7, 6… #> $ target_y <dbl> 267719.1, 270370.6, 270463.6, 269380.6, 268932.1, 269179.3, 2… #> $ dx       <dbl> -917.1063, -651.9320, 370.4737, -210.1946, 103.8862, 596.7662… #> $ dy       <dbl> 365.468249, -42.050863, 268.478200, 13.144895, -575.530782, -… #> $ geometry <POINT [m]> POINT (612293 267353.6), POINT (612225 270412.7), POINT…  # Visualize the residual displacement vectors plot_displacement(swiss_cps, title = \"Displacement Vectors\") +   labs(title = \"\", subtitle = \"\",        x = \"x (m)\",        y = \"y (m)\")"},{"path":"https://kvantas.github.io/mapAI/articles/swiss_data.html","id":"error-assessment-and-model-validation","dir":"Articles","previous_headings":"","what":"Error Assessment and Model Validation","title":"Advanced Analysis with Swiss Data","text":"training final model, crucial assess expected performance. assess_pai_model function provides robust framework . compare four different validation strategies understand model might perform new data. Standard & Spatial Cross-Validation: test 10-fold cross-validation, random data splits “spatial” splits, ensures training validation sets spatially separated. Design-Based Validation: also test validation based sampling probability (probability) stratified random sampling (stratified), useful data points known design structure. Table: Validation performance across different assessment methods.","code":"# Run four different validation methods using a GAM cvra <- assess_pai_model(swiss_cps, method = \"gam\", validation_type = \"random\", k_folds = 10, seed = 1) cvsp <- assess_pai_model(swiss_cps, method = \"gam\", validation_type = \"spatial\", k_folds = 10, seed = 1) valr <- assess_pai_model(swiss_cps, method = \"gam\", validation_type = \"probability\", seed = 1) vals <- assess_pai_model(swiss_cps, method = \"gam\", validation_type = \"stratified\", seed = 1)  # Combine and format the results into a table validation_df <- rbind(cvra, cvsp, valr, vals) %>%   select(Model_Method = Method, Mean_2D_RMSE_m = Mean_RMSE_2D, Std_Deviation_of_RMSE_m = SD_RMSE_2D) %>%   mutate(across(where(is.numeric), ~ round(.x, 1)))  validation_df$type = c(\"Standard 10-fold cross-validation\",                        \"Spatial 10-fold cross-validation\",                        \"Design-based validation\",                        \"Design-based validation using stratified random sampling\")  # Print the comparison table kable(validation_df, caption = \"Table: Validation performance across different assessment methods.\")"},{"path":"https://kvantas.github.io/mapAI/articles/swiss_data.html","id":"final-correction-and-visualization","dir":"Articles","previous_headings":"","what":"Final Correction and Visualization","title":"Advanced Analysis with Swiss Data","text":"Now, confident modeling choice, train final Generalized Additive Model (gam) entire dataset. visualize effect correction, apply model regular reference grid.  plot shows regular grid (dashed grey) warped model corrected grid (solid red). transformation precisely ’s needed align distorted map features true locations.","code":"# Train the final GAM model on all data points final_gam_model <- train_pai_model(swiss_cps, method = \"gam\") #> Training 'gam' model...  # Create a regular line grid to serve as our reference map source_grid <- sf::st_make_grid(swiss_cps, n = c(15, 15)) %>%    st_cast(\"MULTILINESTRING\") %>%    st_sf()  # Apply the trained model to correct the grid gam_corrected_grid <- apply_pai_model(final_gam_model, source_grid) #> Applying PAI model to map features... #> Correction complete.  # Prepare data for plotting source_grid$status <- \"Original (Distorted)\" gam_corrected_grid$status <- \"GAM\" comparison_data  <- rbind(source_grid[, \"status\"], gam_corrected_grid[, \"status\"])  # Create the comparison plot ggplot(comparison_data) +   geom_sf(aes(color = status, linetype = status), fill = NA, linewidth = 0.7) +   scale_color_manual(name = \"Map Status\", values = c(\"Original (Distorted)\" = \"grey50\", \"GAM\" = \"#e41a1c\")) +   geom_point(data = swiss_cps, aes(source_x, source_y), size = 0.2) +   scale_linetype_manual(name = \"Map Status\", values = c(\"Original (Distorted)\" = \"dashed\", \"GAM\" = \"solid\")) +   labs(x = \"x (m)\", y = \"y (m)\") +   coord_sf(datum = sf::st_crs(21781)) +   ggplot2::theme_minimal()"},{"path":"https://kvantas.github.io/mapAI/articles/swiss_data.html","id":"residual-analysis","dir":"Articles","previous_headings":"","what":"Residual Analysis","title":"Advanced Analysis with Swiss Data","text":"applying correction, examine remaining errors, residuals. helps us confirm model captured systematic distortion patterns remaining errors small random.  residual vectors much smaller show obvious spatial pattern, indicating successful model fit.","code":"# Plot the residuals after applying the final GAM model plot_residuals(final_gam_model, swiss_cps) +   labs(     title = \"\",     subtitle = \"\",     x = \"x (m)\",     y = \"y (m)\"   ) #> Calculating model residuals..."},{"path":"https://kvantas.github.io/mapAI/articles/swiss_data.html","id":"advanced-distortion-analysis","dir":"Articles","previous_headings":"","what":"Advanced Distortion Analysis","title":"Advanced Analysis with Swiss Data","text":"quantify nature distortion, use analyze_distortion function dense grid points. allows us map different distortion metrics across entire area. visualize three key metrics: Area Scale: Shows much areas stretched compressed. value 1 means distortion. Maximum Angular Distortion: Measures maximum change angle point. Airy-Kavrayskiy Measure: combined measure areal angular distortion.    can also summarize distortion metrics numerically.","code":"# Create a dense grid of points for a high-resolution analysis analysis_points <- sf::st_make_grid(swiss_cps, n = c(100, 100)) %>% st_centroid() %>% st_sf() distortion_results <- analyze_distortion(final_gam_model, analysis_points) #> Calculating distortion metrics for gam model... #> Finalizing metrics from derivatives... #> Distortion analysis complete.  # Plot 1: Area scale distortion plot_distortion_surface(distortion_results, \"area_scale\", diverging = TRUE) +   labs(title = \"Area Scale Distortion\", subtitle = \"\", x = \"x (m)\", y = \"y (m)\", fill = 'σ') #> Regular grid detected. Creating a surface plot with geom_raster(). #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. #> Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. # Plot 2: Maximum angular distortion plot_distortion_surface(distortion_results, \"max_angular_distortion\", palette = \"magma\") +   labs(title = \"Maximum Angular Distortion\", subtitle = \"\", x = \"x (m)\", y = \"y (m)\", fill = \"2Ω (rad)\") #> Regular grid detected. Creating a surface plot with geom_raster(). #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. #> Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. # Plot 3: Airy-Kavrayskiy distortion measure plot_distortion_surface(distortion_results, \"airy_kavrayskiy\") +   labs(title = \"Airy-Kavrayskiy Combined Distortion\", subtitle = \"\", x = \"x (m)\", y = \"y (m)\", fill = expression(E[\"AK\"])) #> Regular grid detected. Creating a surface plot with geom_raster(). #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. #> Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. # Calculate and print summary statistics for the distortion metrics summary_stats <- st_drop_geometry(distortion_results) %>%   reframe(     Metric = c(\"Areal Scale\", \"Max Angular Distortion (rad)\", \"Airy-Kavrayskiy Measure\"),     Minimum = round(c(min(area_scale), min(max_angular_distortion), min(airy_kavrayskiy)), 2),     Mean = round(c(mean(area_scale), mean(max_angular_distortion), mean(airy_kavrayskiy)), 2),     Maximum = round(c(max(area_scale), max(max_angular_distortion), max(airy_kavrayskiy)), 2)   ) print(kable(summary_stats, caption = \"Table: Summary of distortion metrics from GAM model analysis.\")) #>  #>  #> Table: Table: Summary of distortion metrics from GAM model analysis. #>  #> |Metric                       | Minimum| Mean| Maximum| #> |:----------------------------|-------:|----:|-------:| #> |Areal Scale                  |    0.45| 0.87|    1.41| #> |Max Angular Distortion (rad) |    0.00| 0.21|    0.86| #> |Airy-Kavrayskiy Measure      |    0.00| 0.04|    0.28|"},{"path":"https://kvantas.github.io/mapAI/articles/swiss_data.html","id":"visualizing-distortion-with-indicatrices","dir":"Articles","previous_headings":"","what":"Visualizing Distortion with Indicatrices","title":"Advanced Analysis with Swiss Data","text":"classic way visualize map distortion Tissot’s Indicatrix, shows infinitesimal circle original surface deformed ellipse. can plot control point locations see local distortion characteristics.  size shape ellipses clearly show spatial variation magnitude direction distortion model successfully captured.","code":"# Analyze distortion specifically at the control point locations distortion_at_gcps <- analyze_distortion(final_gam_model, points_to_analyze = swiss_cps) #> Calculating distortion metrics for gam model... #> Finalizing metrics from derivatives... #> Distortion analysis complete.  # Plot the indicatrices (ellipses) at each point plot_indicatrices(distortion_at_gcps,  scale_factor = 700) +   labs(     title = \"Distortion Indicatrices at Control Points\",     subtitle = \"\",     x = \"x (m)\",     y = \"y (m)\"   ) #> Generating indicatrix polygons at source locations..."},{"path":"https://kvantas.github.io/mapAI/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Konstantinos Vantas. Author, maintainer.","code":""},{"path":"https://kvantas.github.io/mapAI/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Konstantinos V (2025). “mapAI: R Package Positional Accuracy Improvement Vector Geospatial Data.” doi:10.5281/zenodo.15767080.","code":"@Misc{,   title = {mapAI: An R Package for Positional Accuracy Improvement of Vector Geospatial Data},   author = {Vantas Konstantinos},   year = {2025},   doi = {https://doi.org/10.5281/zenodo.15767080}, }"},{"path":"https://kvantas.github.io/mapAI/index.html","id":"mapai","dir":"","previous_headings":"","what":"An R Package for Positional Accuracy Improvement of Vector Maps","title":"An R Package for Positional Accuracy Improvement of Vector Maps","text":"mapAI package provides comprehensive, end--end toolkit R Positional Accuracy Improvement (PAI) vector maps. package designed researchers practitioners Geoinformatics GIS need improve geometric quality vector maps also understand quantify nature geometric distortions.","code":""},{"path":"https://kvantas.github.io/mapAI/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"An R Package for Positional Accuracy Improvement of Vector Maps","text":"mapAI framework allows : Import Data: Easily load distorted vector maps corresponding homologous points (GCPs). Train Model: Select suite PAI models (helmert, lm, tps, rf, gam) learn distortion pattern. Acess Model’s Performance: Perform k-fold cross-validation provide robust estimate PAI model’s predictive performance, using random spatial CV methods. Correct Geometry: Apply trained model warp historical map corrected geometric state. Analyze Explain: Use advanced distortion analysis functions, based Tissot’s indicatrix theory, quantify model handles map’s distortions. allows deeper cartographic historical insights, turning model black box explanatory tool. Export Results: Save corrected map standard geospatial file formats.","code":""},{"path":"https://kvantas.github.io/mapAI/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"An R Package for Positional Accuracy Improvement of Vector Maps","text":"can install development version mapAI GitHub using pak package:","code":"# install.packages(\"pak\") pak::pak(\"kvantas/mapAI\")"},{"path":"https://kvantas.github.io/mapAI/index.html","id":"core-workflow-a-complete-example","dir":"","previous_headings":"","what":"Core Workflow: A Complete Example","title":"An R Package for Positional Accuracy Improvement of Vector Maps","text":"example demonstrates primary workflow. first generate synthetic dataset representing distorted map use package’s functions correct .","code":""},{"path":"https://kvantas.github.io/mapAI/index.html","id":"id_1-load-libraries-and-create-demo-data","dir":"","previous_headings":"Core Workflow: A Complete Example","what":"1. Load Libraries and Create Demo Data","title":"An R Package for Positional Accuracy Improvement of Vector Maps","text":"begin using create_demo_data() generate test case complex, noisy distortions.","code":"library(mapAI) library(sf) #> Linking to GEOS 3.13.0, GDAL 3.8.5, PROJ 9.5.1; sf_use_s2() is TRUE library(ggplot2)  # Generate a shapefile and a GCPs CSV with complex noisy distortions # The function returns a list containing the paths to these new files. demo_files <- create_demo_data(type = \"complex\", seed = 42) #>    -> Homologous points saved to: /var/folders/yh/kq6cp_457lg059f3l02r57s80000gn/T//Rtmp4Clda7/demo_gcps.csv #>    -> Distorted map saved to: /var/folders/yh/kq6cp_457lg059f3l02r57s80000gn/T//Rtmp4Clda7/demo_map.shp"},{"path":"https://kvantas.github.io/mapAI/index.html","id":"id_2-read-data-and-train-a-model","dir":"","previous_headings":"Core Workflow: A Complete Example","what":"2. Read Data and Train a Model","title":"An R Package for Positional Accuracy Improvement of Vector Maps","text":"load generated files train Generalized Additive Model (gam), ideal capturing smooth, non-linear distortions present demo data.","code":"# Load the homologous points (GCPs) and the distorted vector map gcp_data <- read_gcps(gcp_path = demo_files$gcp_path, crs = 2100) map_to_correct <- read_map(shp_path = demo_files$shp_path, crs = 2100)  # Train the GAM model using the GCPs gam_model <- train_pai_model(gcp_data, method = \"gam\") #> Training 'gam' model..."},{"path":"https://kvantas.github.io/mapAI/index.html","id":"id_3-apply-correction-and-visualize","dir":"","previous_headings":"Core Workflow: A Complete Example","what":"3. Apply Correction and Visualize","title":"An R Package for Positional Accuracy Improvement of Vector Maps","text":"apply trained model distorted grid. resulting plot, overlays corrected grid original, provides clear visual confirmation model distorted map.","code":"# Apply the model to the distorted map corrected_map <- apply_pai_model(gam_model, map_to_correct) #> Applying PAI model to map features... #> Correction complete.  # For easy plotting, add a 'status' column and combine the maps map_to_correct$status <- \"Original (Distorted)\" corrected_map$status <- \"Corrected\" comparison_data <- rbind(map_to_correct[, \"status\"], corrected_map[, \"status\"])  # Create the final comparison plot ggplot(comparison_data) +   geom_sf(aes(color = status, linetype = status), fill = NA, linewidth = 0.7) +   scale_color_manual(name = \"Map Status\", values = c(\"Original (Distorted)\" = \"grey50\", \"Corrected\" = \"#e41a1c\")) +   scale_linetype_manual(name = \"Map Status\", values = c(\"Original (Distorted)\" = \"dashed\", \"Corrected\" = \"solid\")) +   labs(title = \"Positional Correction of a Distorted Grid\",        subtitle = \"Overlay of original (dashed) and mapAI-corrected (solid) geometries\") +   theme_minimal()"},{"path":"https://kvantas.github.io/mapAI/index.html","id":"from-correction-to-explanation-advanced-distortion-analysis","dir":"","previous_headings":"","what":"From Correction to Explanation: Advanced Distortion Analysis","title":"An R Package for Positional Accuracy Improvement of Vector Maps","text":"key challenge data-driven models understanding learned. mapAI directly addresses providing tools “open black box” analyze properties learned transformation.","code":""},{"path":"https://kvantas.github.io/mapAI/index.html","id":"id_4-quantify-and-visualize-the-distortion-field","dir":"","previous_headings":"From Correction to Explanation: Advanced Distortion Analysis","what":"4. Quantify and Visualize the Distortion Field","title":"An R Package for Positional Accuracy Improvement of Vector Maps","text":"analyze_distortion() function computes local distortion metrics across map space. allows us move simple visual assessment quantitative map distortion. plots provide detailed map model learned apply significant stretching, shrinking, shearing, offering insights may correlate physical map degradation historical cartographic techniques. providing tools, mapAI empowers researchers correct historical maps high accuracy also gain deeper, quantitative understanding geometric properties.","code":"# 1. Create a grid of points for analysis using the pipe (%>%) library(magrittr) analysis_points <- sf::st_make_grid(gcp_data, n = c(25, 25)) %>%   sf::st_centroid() %>%   sf::st_sf()  # 2. Analyze the distortion using our trained GAM model distortion_results <- analyze_distortion(gam_model, analysis_points)  # 3. Plot the distortion surfaces plot_area <- plot_distortion_surface(   distortion_results, metric = \"log2_area_scale\", diverging = TRUE ) + labs(title = \"Areal Distortion (log2σ)\")  plot_shear <- plot_distortion_surface(   distortion_results, metric = \"max_shear\" ) + labs(title = \"Maximum Shear Distortion (°)\")  # Combine plots using the patchwork library if (requireNamespace(\"patchwork\", quietly = TRUE)) {   plot_area + plot_shear } else {   plot_area }"},{"path":"https://kvantas.github.io/mapAI/reference/analyze_distortion.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform a Differential Distortion Analysis — analyze_distortion","title":"Perform a Differential Distortion Analysis — analyze_distortion","text":"Computes comprehensive set detailed distortion metrics PAI model specified locations, based Tissot's indicatrix theory.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/analyze_distortion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform a Differential Distortion Analysis — analyze_distortion","text":"","code":"analyze_distortion(pai_model, points_to_analyze, reference_scale = 1)"},{"path":"https://kvantas.github.io/mapAI/reference/analyze_distortion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform a Differential Distortion Analysis — analyze_distortion","text":"pai_model model object class pai_model train_pai_model(). points_to_analyze sf object points analysis performed. reference_scale single numeric value used normalize area scale calculation. Defaults 1 (normalization).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/analyze_distortion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform a Differential Distortion Analysis — analyze_distortion","text":"sf object containing original points new columns calculated distortion metrics: , b semi-major semi-minor axes Tissot indicatrix. area_scale areal distortion factor (* b). log2_area_scale base-2 logarithm area_scale, symmetric metric centered 0. max_shear maximum angular distortion degrees. max_angular_distortion maximum angular distortion radians (2Omega metric). airy_kavrayskiy Airy-Kavrayskiy measure, balanced metric combining areal angular distortion. theta_a orientation axis maximum scale (degrees).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/analyze_distortion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform a Differential Distortion Analysis — analyze_distortion","text":"function core analytical engine mapAI package. implements differential analysis calculating first partial derivatives spatial transformation learned pai_model. achieved using  numerical differentiation (finite difference) method universally applicable models package (lm, rf, gam, helmert). derivatives, calculates key distortion metrics describe shape, area, angles warped every point. Interpreting Results Model Type: nature output highly dependent model used: gam & tps (Recommended analysis): Produce smooth, differentiable surface. distortion metrics spatially variable provide rich, meaningful understanding distortion changes across map. helmert & lm: Represent global transformations. distortion metrics constant every point. rf: Creates step-like surface. local derivatives may effectively zero, resulting metrics indicating local distortion (e.g.,  area_scale = 1, max_shear = 0).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/analyze_distortion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform a Differential Distortion Analysis — analyze_distortion","text":"","code":"# This example showcases the full analytical workflow.  library(magrittr)  # --- 1. Load data and train a GAM model --- data(gcps) gam_model <- train_pai_model(gcps, method = \"gam\") #> Training 'gam' model...  # --- 2. Create a regular grid of POINTS for analysis --- analysis_points <- sf::st_make_grid(gcps, n = c(25, 25)) %>%   sf::st_centroid() %>%   sf::st_sf()  # --- 3. Run the distortion analysis --- distortion_results <- analyze_distortion(gam_model, analysis_points) #> Calculating distortion metrics for gam model... #> Finalizing metrics from derivatives... #> Distortion analysis complete.  # --- 4. Visualize the area scale --- plot_distortion_surface(   distortion_results,   metric = \"area_scale\") #> Regular grid detected. Creating a surface plot with geom_raster(). #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead."},{"path":"https://kvantas.github.io/mapAI/reference/apply_pai_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a Trained PAI Model to Correct a Vector Map — apply_pai_model","title":"Apply a Trained PAI Model to Correct a Vector Map — apply_pai_model","text":"Applies trained pai_model object sf vector map, correcting position vertices based learned transformation.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/apply_pai_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a Trained PAI Model to Correct a Vector Map — apply_pai_model","text":"","code":"apply_pai_model(pai_model, map)"},{"path":"https://kvantas.github.io/mapAI/reference/apply_pai_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a Trained PAI Model to Correct a Vector Map — apply_pai_model","text":"pai_model object class pai_model returned train_pai_model(). map sf object representing vector map corrected.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/apply_pai_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a Trained PAI Model to Correct a Vector Map — apply_pai_model","text":"new sf object corrected geometry.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/apply_pai_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a Trained PAI Model to Correct a Vector Map — apply_pai_model","text":"function final step PAI workflow, applying learned spatial correction target map. uses robust feature--feature iteration correctly handles standard simple multi-part geometry types (POINT, LINESTRING, POLYGON, etc.).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/apply_pai_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a Trained PAI Model to Correct a Vector Map — apply_pai_model","text":"","code":"# This example demonstrates a full workflow with POINT geometry.  # --- 1. Load Data and Train Model --- data(gcps) # gcps is an sf object with POINT geometry gam_model <- train_pai_model(gcps, method = \"gam\") #> Training 'gam' model...  # --- 2. Apply the Model to Correct the Points --- corrected_points <- apply_pai_model(gam_model, gcps) #> Applying PAI model to map features... #> Correction complete.  # --- 3. Inspect and Visualize --- # The coordinates of the corrected points should be different. head(sf::st_coordinates(gcps)) #>             X       Y #> [1,] 268828.1 4488391 #> [2,] 268684.7 4488627 #> [3,] 268710.3 4488347 #> [4,] 268509.3 4488540 #> [5,] 268516.0 4488406 #> [6,] 268840.4 4488505 head(sf::st_coordinates(corrected_points)) #>             X       Y #> [1,] 268828.3 4488391 #> [2,] 268684.9 4488627 #> [3,] 268710.2 4488347 #> [4,] 268509.6 4488540 #> [5,] 268515.7 4488405 #> [6,] 268840.7 4488505  # Visually confirm the points have moved plot(sf::st_geometry(gcps), col = 'grey', pch = 4, cex=0.5,      main = \"Original (Grey) vs. Corrected (Red) Points\") plot(sf::st_geometry(corrected_points), col = 'red', pch = 16, cex=0.5, add = TRUE)"},{"path":"https://kvantas.github.io/mapAI/reference/assess_pai_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Assess PAI Model Performance — assess_pai_model","title":"Assess PAI Model Performance — assess_pai_model","text":"Performs model validation estimate PAI model's predictive performance using k-fold cross-validation design-based probability sampling.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/assess_pai_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assess PAI Model Performance — assess_pai_model","text":"","code":"assess_pai_model(   gcp_data,   method,   validation_type = \"random\",   k_folds = 5,   train_split_ratio = 0.8,   n_strata = 4,   seed = 123,   ... )"},{"path":"https://kvantas.github.io/mapAI/reference/assess_pai_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assess PAI Model Performance — assess_pai_model","text":"gcp_data sf object homologous points, read_gcps(). method character string specifying algorithm assess. One : \"lm\", \"gam\", \"rf\", \"helmert\", \"tps\". validation_type character string specifying validation strategy. One \"random\", \"spatial\", \"probability\", \"stratified\". k_folds integer number folds CV. used validation_type \"random\" \"spatial\". Defaults 5. train_split_ratio numeric value 0 1. proportion data training set. Used \"probability\" \"stratified\" types. Defaults 0.8. n_strata integer specifying number strata create stratified sampling. used validation_type = \"stratified\". Defaults 4 (quartiles). seed integer setting random seed reproducibility. ... Additional arguments passed train_pai_model function.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/assess_pai_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assess PAI Model Performance — assess_pai_model","text":"data frame summarizing validation results.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/assess_pai_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assess PAI Model Performance — assess_pai_model","text":"Model validation crucial understanding well model generalize new data. function automates process. Validation Types: random: Standard k-fold cross-validation. spatial: Spatial k-fold cross-validation. probability: Design-based validation using single train/test split based simple random sampling. stratified: Design-based validation using stratified random sampling. single train/test split performed. Strata created based quantiles Euclidean distance error vectors (dx, dy), ensuring validation set represents error magnitudes proportionally.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/assess_pai_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assess PAI Model Performance — assess_pai_model","text":"","code":"if (FALSE) { # \\dontrun{ # --- 1. create a demo data set demo_files <- create_demo_data(seed = 42) gcp_data <- read_gcps(gcp_path = demo_files$gcp_path, crs = 3857)  # --- 2. Assess with RANDOM k-fold CV --- random_assessment <- assess_pai_model(   gcp_data, method = \"rf\", validation_type = \"random\", k_folds = 5 ) print(random_assessment)  # --- 3. Assess with SPATIAL k-fold CV --- spatial_assessment <- assess_pai_model(   gcp_data, method = \"rf\", validation_type = \"spatial\", k_folds = 5 ) print(spatial_assessment)  # --- 4. Assess with PROBABILITY (simple random) sampling --- prob_assessment <- assess_pai_model(   gcp_data, method = \"rf\", validation_type = \"probability\", train_split_ratio = 0.75 ) print(prob_assessment)  # --- 5. Assess with STRATIFIED probability sampling --- stratified_assessment <- assess_pai_model(   gcp_data,   method = \"rf\",   validation_type = \"stratified\",   train_split_ratio = 0.75,   n_strata = 4 # Use quartiles for stratification ) print(stratified_assessment) } # }"},{"path":"https://kvantas.github.io/mapAI/reference/create_demo_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Simulated Historical Map Dataset for Demonstration — create_demo_data","title":"Create a Simulated Historical Map Dataset for Demonstration — create_demo_data","text":"Generates simulated dataset representing distorted historical map corresponding set homologous points (GCPs), saving files.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/create_demo_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Simulated Historical Map Dataset for Demonstration — create_demo_data","text":"","code":"create_demo_data(   type = \"complex\",   noise_sd = 0.5,   n_points = 15,   output_dir = tempdir(),   seed = 42,   grid_limits = c(0, 100, 0, 100),   helmert_params = list(s = 1.005, angle_deg = 1, tx = 2, ty = -3),   poly_params = list(cE1 = 2e-05, cE2 = -8e-04, cN1 = 2e-04, cN2 = 0.0015),   gauss_params = list(A = 4, Ec = 50, Nc = 0, sigma2 = 20) )"},{"path":"https://kvantas.github.io/mapAI/reference/create_demo_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Simulated Historical Map Dataset for Demonstration — create_demo_data","text":"type character string specifying distortion type. One \"helmert\", \"nonlinear\", \"complex\". Defaults \"complex\". noise_sd numeric value standard deviation Gaussian noise added distorted coordinates. Defaults 0.5. n_points integer specifying number points along axis initial grid. total number homologous points n_points^2. Defaults 15. output_dir character string specifying directory demo files saved. Defaults temporary directory (tempdir()). seed integer setting random seed reproducibility. Defaults 42. grid_limits numeric vector form c(xmin, xmax, ymin, ymax) defining extent \"true\" grid. Defaults c(0, 100, 0, 100). helmert_params list parameters Helmert transformation: s (scale), angle_deg (rotation degrees), tx (translation x), ty (translation y). Defaults list(s = 1.005, angle_deg = 1, tx = 2, ty = -3). poly_params list coefficients (cE1, cE2, cN1, cN2) polynomial warp. Defaults list(cE1 = 0.00002, cE2 = -0.0008, cN1 = 0.0002, cN2 = 0.0015). gauss_params list parameters Gaussian warp: (amplitude), Ec, Nc (center coordinates), sigma2 (variance). Defaults list(= 4, Ec = 50, Nc = 0, sigma2 = 20).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/create_demo_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Simulated Historical Map Dataset for Demonstration — create_demo_data","text":"list containing full paths generated files: shp_path path 'demo_map.shp' shapefile. gcp_path path 'demo_gcps.csv' file.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/create_demo_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Simulated Historical Map Dataset for Demonstration — create_demo_data","text":"function implements simulation framework described Vantas Mirkopoulou, 2025. first creates regular grid points representing \"true\" geography. applies one three distortion types paper: \"helmert\": simple global transformation involving scale, rotation, translation. \"nonlinear\": Helmert transformation followed smooth polynomial warp, simulating material stretching. \"complex\" (Default): Combines Helmert nonlinear warp localized Gaussian deformation, simulating complex mix global, regional, local errors. Finally, random noise added distorted coordinates. function outputs shapefile representing distorted grid (set grid lines) CSV file homologous points ready use read_correction_data().","code":""},{"path":"https://kvantas.github.io/mapAI/reference/create_demo_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Simulated Historical Map Dataset for Demonstration — create_demo_data","text":"","code":"if (FALSE) { # \\dontrun{ # --- 1. Generate the demonstration data with default complex distortion --- demo_files <- create_demo_data(type = \"complex\", noise_sd = 0.5)  # --- Generate data with only Helmert distortion and custom parameters --- custom_helmert_params <- list(s = 1.0, angle_deg = 5, tx = 10, ty = 15) helmert_files <- create_demo_data(   type = \"helmert\",   helmert_params = custom_helmert_params,   n_points = 10  )  # --- 2. Use the generated files in the new workflow --- # Read the GCPs and map separately, providing the CRS gcp_data <- read_gcps(gcp_path = demo_files$gcp_path, crs = 3857) map_to_correct <- read_map(shp_path = demo_files$shp_path, crs = 3857)  # --- 3. Train a model --- rf_model <- train_pai_model(gcp_data, method = \"rf\")  # --- 4. Apply the trained model to the map --- corrected_map <- apply_pai_model(pai_model = rf_model, map = map_to_correct)  # --- 5. Visualize the results --- plot_correction_surface(rf_model, gcp_data) } # }"},{"path":"https://kvantas.github.io/mapAI/reference/gcps.html","id":null,"dir":"Reference","previous_headings":"","what":"Ground Control Points (GCPs) for Map Correction — gcps","title":"Ground Control Points (GCPs) for Map Correction — gcps","text":"dataset containing Ground Control Points (GCPs) used correcting vector map parcels package. points represent homologous locations identified source (uncorrected) map modern land survey.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/gcps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ground Control Points (GCPs) for Map Correction — gcps","text":"","code":"gcps"},{"path":"https://kvantas.github.io/mapAI/reference/gcps.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Ground Control Points (GCPs) for Map Correction — gcps","text":"sf object 300 features 6 variables: source_x Numeric. X-coordinate GCP source map. source_y Numeric. Y-coordinate GCP source map. target_x Numeric. X-coordinate GCP target map. target_y Numeric. Y-coordinate GCP target map. dx Numeric. difference X-coordinates (target_x - source_x). dy Numeric. difference Y-coordinates (target_y - source_y). geometry sfc_POINT. sf point geometry representing GCPs target CRS (EPSG:2100).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/gcps.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Ground Control Points (GCPs) for Map Correction — gcps","text":"Part dataset used paper https://doi.org/10.1111/tgis.70076","code":""},{"path":"https://kvantas.github.io/mapAI/reference/gcps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ground Control Points (GCPs) for Map Correction — gcps","text":"","code":"if (interactive()) {   # plot the difference in X-coordinates dx   plot((gcps[\"dx\"])) }"},{"path":"https://kvantas.github.io/mapAI/reference/helmert.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Helmert 2D Transformation Solver — helmert","title":"Internal Helmert 2D Transformation Solver — helmert","text":"Calculates four parameters 2D similarity (Helmert) transformation using standard, numerically stable least-squares solution based centroids. internal function called train_pai_model.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/helmert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Helmert 2D Transformation Solver — helmert","text":"","code":"helmert(source_x, source_y, target_x, target_y)"},{"path":"https://kvantas.github.io/mapAI/reference/helmert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Helmert 2D Transformation Solver — helmert","text":"source_x Numeric vector approximate ('') x coordinates. source_y Numeric vector approximate ('') y coordinates. target_x Numeric vector actual ('') x coordinates. target_y Numeric vector actual ('') y coordinates.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/helmert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Helmert 2D Transformation Solver — helmert","text":"object class helmert containing calculated coefficients original data centroids, ready use predict.pai_model.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/mapAI.html","id":null,"dir":"Reference","previous_headings":"","what":"mapAI: Positional Accuracy Improvement for Historical Maps — mapAI","title":"mapAI: Positional Accuracy Improvement for Historical Maps — mapAI","text":"mapAI package provides cohesive, end--end toolkit R Positional Accuracy Improvement (PAI) distortion analysis vector maps.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/mapAI.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"mapAI: Positional Accuracy Improvement for Historical Maps — mapAI","text":"package designed researchers practitioners geomatics GIS, provides complete, modular workflow guides user importing data final analysis visualization.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/mapAI.html","id":"the-core-workflow","dir":"Reference","previous_headings":"","what":"The Core Workflow","title":"mapAI: Positional Accuracy Improvement for Historical Maps — mapAI","text":"main workflow follows logical sequence: Data Handling: Imports spatial data control points using read_map() read_gcps(). package also includes functions generate synthetic data (create_demo_data()) save results (write_map()). Model Training & Validation: Train correction model using train_pai_model() choice methods (\"helmert\", \"lm\", \"rf\", \"gam\"). Robustly evaluate model performance using spatial cross-validation assess_pai_model(). Geometric Correction: Apply trained model full vector map get geometrically corrected version using apply_pai_model(). Distortion Analysis & Visualization: Go beyond correction quantify understand distortion learns PAI model . Use analyze_distortion() compute detailed metrics based Tissot's indicatrix theory (e.g., areal scale, angular distortion). Use dedicated plotting functions (plot_displacement(), plot_residuals(), plot_distortion_surface(), plot_indicatrices()) create compelling, publication-quality visualizations error distortion patterns.","code":""},{"path":[]},{"path":"https://kvantas.github.io/mapAI/reference/mapAI.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mapAI: Positional Accuracy Improvement for Historical Maps — mapAI","text":"Maintainer: Konstantinos Vantas kon.vantas@gmail.com (ORCID)","code":""},{"path":"https://kvantas.github.io/mapAI/reference/parcels.html","id":null,"dir":"Reference","previous_headings":"","what":"Vector Map Parcels for Correction — parcels","title":"Vector Map Parcels for Correction — parcels","text":"dataset containing vector map parcels (polygons cadastral map) intended corrected using geospatial transformation methods.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/parcels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vector Map Parcels for Correction — parcels","text":"","code":"parcels"},{"path":"https://kvantas.github.io/mapAI/reference/parcels.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Vector Map Parcels for Correction — parcels","text":"sf object 493 parcel polygon geometries several variables: KAK Numeric. unique identifier parcel. area_old units object. original area polygon feature, calculated read_map() geometry sfc_POLYGON sfc_MULTIPOLYGON. sf polygon geometry representing parcels target CRS (EPSG:2100).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/parcels.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Vector Map Parcels for Correction — parcels","text":"Part dataset 1925 urban cadastral map Kastoria, Greece used http://dx.doi.org/10.1111/tgis.70076","code":""},{"path":"https://kvantas.github.io/mapAI/reference/parcels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vector Map Parcels for Correction — parcels","text":"","code":"if (interactive()) {   plot(sf::st_geometry(parcels)) }"},{"path":"https://kvantas.github.io/mapAI/reference/plot_correction_surface.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the Learned Correction Surface — plot_correction_surface","title":"Plot the Learned Correction Surface — plot_correction_surface","text":"Visualizes spatial correction field (dx, dy) learned PAI model.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_correction_surface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the Learned Correction Surface — plot_correction_surface","text":"","code":"plot_correction_surface(pai_model, gcp_data, n_grid = 100, plot_gcps = TRUE)"},{"path":"https://kvantas.github.io/mapAI/reference/plot_correction_surface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the Learned Correction Surface — plot_correction_surface","text":"pai_model trained pai_model object returned train_pai_model(). gcp_data sf object homologous points used training model. n_grid resolution interpolation grid used create smooth surface. Higher values create detailed plot take longer compute. Defaults 100. plot_gcps logical value indicating whether plot GCP locations correction surfaces. Defaults TRUE.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_correction_surface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the Learned Correction Surface — plot_correction_surface","text":"patchwork object containing two ggplot plots, one dx one dy.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_correction_surface.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot the Learned Correction Surface — plot_correction_surface","text":"function serves key diagnostic tool understanding behavior trained pai_model. creates two raster plots: one dx (East-West) corrections one dy (North-South) corrections. color intensity plots reveals magnitude correction given location. Contour lines show gradient change, black crosses mark location original Ground Control Points (GCPs), showing model direct information learn . examining surfaces, users can: Understand spatial nature distortion model learned. Identify areas high vs. low correction. Spot potential issues like extreme corrections unusual artifacts, especially edges data model extrapolating.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_correction_surface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the Learned Correction Surface — plot_correction_surface","text":"","code":"if (FALSE) { # \\dontrun{ # This example demonstrates how to train a model and then visualize # what it has learned.  # --- 1. Load required data from the package --- data(gcps)  # --- 2. Train a model to visualize --- # A GAM (Generalized Additive Model) is a great choice for this # because it naturally produces smooth surfaces that are easy to interpret. pai_model_gam <- train_pai_model(gcps, method = \"gam\")  # --- 3. Generate and display the plot --- # This creates the two-panel plot showing the dx and dy correction fields. correction_plot <- plot_correction_surface(   pai_model = pai_model_gam,   gcp_data = gcps,   n_grid = 75 # Using a slightly coarser grid for a quick example )  # To display the plot in an interactive session: print(correction_plot)  # You can also hide the GCPs correction_plot_no_gcps <- plot_correction_surface(   pai_model = pai_model_gam,   gcp_data = gcps,   plot_gcps = FALSE ) print(correction_plot_no_gcps) } # }"},{"path":"https://kvantas.github.io/mapAI/reference/plot_displacement.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Displacement Vectors — plot_displacement","title":"Plot Displacement Vectors — plot_displacement","text":"Creates visualization displacement vectors source (distorted) target (true) coordinates set homologous points.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_displacement.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Displacement Vectors — plot_displacement","text":"","code":"plot_displacement(   gcp_data,   title = \"Distortion Displacement Vectors\",   subtitle = \"Arrows point from distorted to true locations\",   arrow_color = \"darkred\",   point_color = \"red\" )"},{"path":"https://kvantas.github.io/mapAI/reference/plot_displacement.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Displacement Vectors — plot_displacement","text":"gcp_data sf object homologous points, typically output read_gcps(). Must contain source_x, source_y, target_x, target_y columns. title character string plot's main title. subtitle character string plot's subtitle. arrow_color character string specifying color displacement arrows. point_color character string specifying color points marking source locations.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_displacement.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Displacement Vectors — plot_displacement","text":"ggplot object, can customized using standard ggplot2 syntax.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_displacement.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Displacement Vectors — plot_displacement","text":"function key exploratory tool understanding nature magnitude positional error dataset correction. plots arrows originate distorted source coordinates point correct target coordinates. provides immediate visual sense spatial patterns distortion (e.g., rotation, scaling, non-linear warping).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_displacement.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Displacement Vectors — plot_displacement","text":"","code":"# --- 1. First, create a demo dataset to work with --- demo_files <- create_demo_data(type = \"complex\") #>    -> Homologous points saved to: /tmp/RtmpzBqobt/demo_gcps.csv #>    -> Distorted map saved to: /tmp/RtmpzBqobt/demo_map.shp gcp_data <- read_gcps(gcp_path = demo_files$gcp_path, crs = 3857)  # --- 2. Create the default displacement plot --- plot_displacement(gcp_data)   # --- 3. Customize the plot with different titles and colors --- plot_displacement(   gcp_data,   title = \"My Custom Displacement Plot\",   subtitle = \"Visualizing error vectors\",   arrow_color = \"blue\",   point_color = \"orange\" )"},{"path":"https://kvantas.github.io/mapAI/reference/plot_distortion_surface.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize a Distortion Metric — plot_distortion_surface","title":"Visualize a Distortion Metric — plot_distortion_surface","text":"Creates visualization continuous distortion metric output analyze_distortion().","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_distortion_surface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize a Distortion Metric — plot_distortion_surface","text":"","code":"plot_distortion_surface(   distortion_sf,   metric,   gcp_data = NULL,   palette = \"viridis\",   diverging = FALSE )"},{"path":"https://kvantas.github.io/mapAI/reference/plot_distortion_surface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize a Distortion Metric — plot_distortion_surface","text":"distortion_sf sf object points returned analyze_distortion(). metric character string specifying name metric column plot. Must one \"\", \"b\", \"area_scale\", \"log2_area_scale\", \"max_shear\", \"max_angular_distortion\", \"airy_kavrayskiy\", \"theta_a\". gcp_data optional sf object original GCPs overlay plot context. palette character string specifying name viridis color palette (e.g., \"viridis\", \"magma\", \"cividis\"), used diverging=FALSE. diverging logical value. TRUE, diverging color scale used, ideal metrics like area_scale log2_area_scale.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_distortion_surface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize a Distortion Metric — plot_distortion_surface","text":"ggplot object, can customized.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_distortion_surface.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize a Distortion Metric — plot_distortion_surface","text":"function visualizes distortion field exists source map's coordinate space. allows direct visual correlation features original map calculated distortion metrics. points regular grid (recommended): creates rasterized surface plot using geom_raster(), ideal visualizing continuous distortion surfaces. create regular grid, use pattern: sf::st_make_grid(...) %>% sf::st_centroid() %>% sf::st_sf(). scattered, irregular points (like original GCPs): creates point plot point colored metric value. avoids memory errors still provides useful diagnostic plot, along message recommending use grid true surface plot. Interpreting Plots Model Type visual output depend model used generate distortion_sf data: gam tps model data: produce smooth, continuous surface withcspatially varying colors, highly informative. idealcmodel function. helmert lm model data: produce plot single, uniform color, underlying distortion metrics constant across map. rf model data: produce plot indicating Identity transformation (area_scale = 1, max_shear = 0). RF might excellent correction tool, analysis informative . may see benign warning ggplot2 \"uneven horizontal intervals.\" caused minor floating-point inaccuracies grid coordinates can safely ignored; plot still accurate.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_distortion_surface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize a Distortion Metric — plot_distortion_surface","text":"","code":"# --- 1. Train a GAM model for the best visual results --- library(magrittr) data(swiss_cps) gam_model <- train_pai_model(swiss_cps, method = \"gam\") #> Training 'gam' model...  # --- 2. Create a regular grid of POINTS for analysis --- analysis_points <- sf::st_make_grid(swiss_cps, n = c(25, 25)) %>%   sf::st_centroid() %>%   sf::st_sf()  distortion_on_grid <- analyze_distortion(gam_model, analysis_points) #> Calculating distortion metrics for gam model... #> Finalizing metrics from derivatives... #> Distortion analysis complete.  # --- 3. Plot a metric using a standard sequential scale --- plot_distortion_surface(   distortion_on_grid,   metric = \"max_shear\",   palette = \"magma\" ) #> Regular grid detected. Creating a surface plot with geom_raster(). #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead.   # --- 4. Plot a metric using a diverging scale --- # 'log2_area_scale' is ideal for this, as it's centered at 0. plot_distortion_surface(   distortion_on_grid,   metric = \"log2_area_scale\",   diverging = TRUE ) #> Regular grid detected. Creating a surface plot with geom_raster(). #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead."},{"path":"https://kvantas.github.io/mapAI/reference/plot_indicatrices.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Tissot's Indicatrices of Distortion — plot_indicatrices","title":"Plot Tissot's Indicatrices of Distortion — plot_indicatrices","text":"Visualizes distortion drawing Tissot's indicatrices (ellipses) original source locations.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_indicatrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Tissot's Indicatrices of Distortion — plot_indicatrices","text":"","code":"plot_indicatrices(   distortion_sf,   scale_factor = 1,   fill_color = \"lightblue\",   border_color = \"black\" )"},{"path":"https://kvantas.github.io/mapAI/reference/plot_indicatrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Tissot's Indicatrices of Distortion — plot_indicatrices","text":"distortion_sf sf object points returned analyze_distortion(). must contain columns , b, theta_a. scale_factor numeric value control size plotted ellipses better visibility. need adjust based map's scale. fill_color character string specifying fill color ellipses. border_color character string specifying border color ellipses.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_indicatrices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Tissot's Indicatrices of Distortion — plot_indicatrices","text":"ggplot object containing distortion ellipses plotted source coordinate space.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_indicatrices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Tissot's Indicatrices of Distortion — plot_indicatrices","text":"function creates powerful visual representation distortion, following methodology Boùùaert et al. (2016). takes results analyze_distortion() draws ellipse analyzed point, centered source coordinate. allows direct visual assessment distortion historical map's geographic space. ellipse graphically shows magnitude direction distortion location: shape ellipse shows angular distortion (shear). size ellipse shows areal distortion. orientation ellipse shows direction maximum scale.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_indicatrices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Tissot's Indicatrices of Distortion — plot_indicatrices","text":"","code":"# --- 1. Train a model and analyze distortion --- data(gcps) gam_model <- train_pai_model(gcps, method = \"gam\") #> Training 'gam' model... distortion_at_gcps <- analyze_distortion(gam_model, gcps) #> Calculating distortion metrics for gam model... #> Finalizing metrics from derivatives... #> Distortion analysis complete.  # --- 2. Plot the indicatrices --- # Note that the pai_model is no longer needed. The function plots the # distortion centered on the source locations from the distortion_sf object. # The scale_factor needs to be large enough to make the ellipses visible. plot_indicatrices(   distortion_sf = distortion_at_gcps,   scale_factor = 20 ) #> Generating indicatrix polygons at source locations..."},{"path":"https://kvantas.github.io/mapAI/reference/plot_residuals.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Model Residuals at Homologous Point Locations — plot_residuals","title":"Plot Model Residuals at Homologous Point Locations — plot_residuals","text":"Creates vector plot showing residual errors trained PAI model location Ground Control Points (GCPs).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_residuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Model Residuals at Homologous Point Locations — plot_residuals","text":"","code":"plot_residuals(   pai_model,   gcp_data,   title = \"Model Residual Error Vectors\",   subtitle = \"Arrows point from predicted to true target locations\",   arrow_color = \"darkblue\",   point_color = \"blue\" )"},{"path":"https://kvantas.github.io/mapAI/reference/plot_residuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Model Residuals at Homologous Point Locations — plot_residuals","text":"pai_model object class pai_model train_pai_model(). gcp_data sf object homologous points, read_gcps(). title character string plot's main title. subtitle character string plot's subtitle. arrow_color character string specifying color residual arrows. point_color character string specifying color points marking predicted locations.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_residuals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Model Residuals at Homologous Point Locations — plot_residuals","text":"ggplot object, can customized.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_residuals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Model Residuals at Homologous Point Locations — plot_residuals","text":"crucial diagnostic function assessing model performance. answers question: \"errors model fail correct?\" function first predicts correction GCP. calculates model's predicted target coordinate point. resulting arrows drawn starting predicted target location pointing true target location. perfect model zero-length residual vectors. presence long arrows clear spatial patterns residuals may indicate chosen model complex enough capture full distortion pattern.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/plot_residuals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Model Residuals at Homologous Point Locations — plot_residuals","text":"","code":"# --- 1. Load data and train a simple model --- data(swiss_cps) # A helmert model is used as it will leave significant residuals. helmert_model <- train_pai_model(swiss_cps, method = \"helmert\") #> Fitting Helmert transformation...  # --- 2. Plot the residuals with default colors --- plot_residuals(helmert_model, swiss_cps) #> Calculating model residuals...   # --- 3. Compare with a more advanced model ---   gam_model <- train_pai_model(swiss_cps, method = \"gam\") #> Training 'gam' model...  # The residuals for the GAM model should be much smaller and more random. plot_residuals(gam_model, swiss_cps,                arrow_color = \"#006d2c\", # A dark green                point_color = \"#66c2a5\"  # A lighter green ) #> Calculating model residuals..."},{"path":"https://kvantas.github.io/mapAI/reference/predict.pai_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Method for pai_model Objects — predict.pai_model","title":"Predict Method for pai_model Objects — predict.pai_model","text":"Predicts spatial corrections (dx, dy) trained pai_model object. S3 method generic predict() function.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/predict.pai_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Method for pai_model Objects — predict.pai_model","text":"","code":"# S3 method for class 'pai_model' predict(object, newdata, ...)"},{"path":"https://kvantas.github.io/mapAI/reference/predict.pai_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Method for pai_model Objects — predict.pai_model","text":"object trained model object class pai_model returned train_pai_model(). newdata data.frame source_x source_y columns generate predictions. ... Additional arguments passed underlying predict methods (e.g., predict.lm, predict.gam).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/predict.pai_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Method for pai_model Objects — predict.pai_model","text":"data.frame predicted dx dy columns, number rows newdata.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/predict.pai_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict Method for pai_model Objects — predict.pai_model","text":"function provides core prediction logic models created train_pai_model(). S3 method, called directly (e.g., predict.pai_model(...)), rather generic predict() function (e.g., predict(my_model, ...)). Key features method include: Automatic Model Handling: transparently handles different output structures helmert,tps, gam, lm, rf models, always returning consistent data.frame. Robust NA Handling: correctly handles NA values newdata predictors. Rows NA inputs produce NA outputs, ensuring output number rows input preventing errors underlying prediction functions.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/predict.pai_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Method for pai_model Objects — predict.pai_model","text":"","code":"if (FALSE) { # \\dontrun{ # This example shows how the generic `predict()` function can be used # on any model trained by `train_pai_model()`.  # --- 1. Load Data and Train Models --- data(gcps) # Load the package's built-in homologous points  # Train two different types of models pai_model_gam <- train_pai_model(gcps, method = \"gam\") pai_model_rf <- train_pai_model(gcps, method = \"rf\")  # --- 2. Create New Data for Prediction --- # We'll create a small data frame of new points. # Note the third row contains an NA to demonstrate robust NA handling. new_points_to_predict <- data.frame(   source_x = c(241643.0, 241650.0, NA),   source_y = c(4477383, 4477370, 4477390) )  # --- 3. Use the Generic `predict()` Function --- # The same `predict()` call works for both model objects.  # Predict using the GAM model predictions_from_gam <- predict(pai_model_gam, newdata = new_points_to_predict)  # Predict using the Random Forest model predictions_from_rf <- predict(pai_model_rf, newdata = new_points_to_predict)  # --- 4. Inspect the Results --- print(\"Predictions from GAM model:\") print(predictions_from_gam) #>           dx        dy #> 1  0.5898319 -0.163833 #> 2  0.5908929 -0.161099 #> 3         NA        NA  print(\"Predictions from Random Forest model:\") print(predictions_from_rf) } # }"},{"path":"https://kvantas.github.io/mapAI/reference/read_gcps.html","id":null,"dir":"Reference","previous_headings":"","what":"Read and Prepare Homologous Points (GCPs) — read_gcps","title":"Read and Prepare Homologous Points (GCPs) — read_gcps","text":"Reads CSV file containing homologous points prepares modeling calculating displacement vectors creating sf object.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/read_gcps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read and Prepare Homologous Points (GCPs) — read_gcps","text":"","code":"read_gcps(gcp_path, crs)"},{"path":"https://kvantas.github.io/mapAI/reference/read_gcps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read and Prepare Homologous Points (GCPs) — read_gcps","text":"gcp_path character string specifying path CSV file homologous points. crs coordinate reference system (CRS) source_x source_y coordinates. required parameter ensure spatial context. can EPSG code (e.g., 32632) WKT string.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/read_gcps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read and Prepare Homologous Points (GCPs) — read_gcps","text":"sf object homologous points, point geometries based source coordinates calculated dx dy displacement columns.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/read_gcps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read and Prepare Homologous Points (GCPs) — read_gcps","text":"function first step modeling workflow. requires CSV file four specific columns: source_x source_y (coordinates old/distorted map) target_x target_y (coordinates reference/true map). calculates dx dy errors models learn predict.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/read_gcps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read and Prepare Homologous Points (GCPs) — read_gcps","text":"","code":"if (FALSE) { # \\dontrun{ # First, create a demo CSV file demo_files <- create_demo_data()  # Read the GCPs, providing the CRS for the source coordinates # (The demo data uses a placeholder CRS of 3857) gcp_data <- read_gcps(gcp_path = demo_files$gcp_path, crs = 3857)  # The output is now ready for model training print(gcp_data) } # }"},{"path":"https://kvantas.github.io/mapAI/reference/read_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a Vector Map for Correction — read_map","title":"Read a Vector Map for Correction — read_map","text":"Reads vector map (e.g., shapefile) intended corrected.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/read_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a Vector Map for Correction — read_map","text":"","code":"read_map(shp_path, crs = NA)"},{"path":"https://kvantas.github.io/mapAI/reference/read_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a Vector Map for Correction — read_map","text":"shp_path character string specifying path input map file (e.g., shapefile). crs optional coordinate reference system (CRS) assign input file lacks one. Can EPSG code (e.g., 32632) WKT string.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/read_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a Vector Map for Correction — read_map","text":"sf object map corrected.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/read_map.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read a Vector Map for Correction — read_map","text":"function reads geospatial file using sf::st_read. file contains polygon geometries already area column named 'area_old', function calculate area feature add .","code":""},{"path":"https://kvantas.github.io/mapAI/reference/read_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read a Vector Map for Correction — read_map","text":"","code":"if (FALSE) { # \\dontrun{ # First, create a demo shapefile demo_files <- create_demo_data()  # Read the map that needs correction map_to_correct <- read_map(shp_path = demo_files$shp_path)  # The output is now ready to be used in the `correct_map()` function # after a model has been trained. plot(sf::st_geometry(map_to_correct)) } # }"},{"path":"https://kvantas.github.io/mapAI/reference/swiss_cps.html","id":null,"dir":"Reference","previous_headings":"","what":"Swiss Control Points for Distortion Analysis — swiss_cps","title":"Swiss Control Points for Distortion Analysis — swiss_cps","text":"dataset 343 Control Points (CPs) based sample dataset MapAnalyst distortion analysis software. ideal analyzing complex, non-linear distortions.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/swiss_cps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swiss Control Points for Distortion Analysis — swiss_cps","text":"","code":"swiss_cps"},{"path":"https://kvantas.github.io/mapAI/reference/swiss_cps.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Swiss Control Points for Distortion Analysis — swiss_cps","text":"sf data frame 300 rows (points) 7 columns: source_x Numeric. X-coordinate source map (already globally aligned). source_y Numeric. Y-coordinate source map (already globally aligned). target_x Numeric. X-coordinate reference map. target_y Numeric. Y-coordinate reference map. dx Numeric. residual difference X (target_x - source_x). dy Numeric. residual difference Y (target_y - source_y). geometry sfc_POINT. sf point geometry representing source_x source_y locations Swiss CH1903 / LV03 coordinate system (EPSG:21781).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/swiss_cps.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Swiss Control Points for Distortion Analysis — swiss_cps","text":"Data originally provided sample dataset MapAnalyst distortion analysis software. See http://mapanalyst.cartography.ch.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/swiss_cps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Swiss Control Points for Distortion Analysis — swiss_cps","text":"dataset derived sample data provided MapAnalyst software (http://mapanalyst.cartography.ch). defining characteristic dataset source coordinates (source_x, source_y) already globally aligned target coordinates using Helmert transformation. remaining differences (dx, dy) therefore represent complex, non-linear residual distortions. makes dataset excellent test case evaluating ability models like gam rf model correct challenging error patterns, simple helmert lm model able address.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/swiss_cps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Swiss Control Points for Distortion Analysis — swiss_cps","text":"","code":"# This example demonstrates a powerful use case for the swiss_cps dataset: # 1. Load the data. # 2. Train a GAM model to learn the complex, non-linear residual errors. # 3. Visualize the learned distortion surface.  library(mapAI) library(sf) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE  # Load the dataset data(swiss_cps)  # Train a GAM model. It will learn the non-linear patterns that remain # after the initial Helmert alignment. gam_model <- train_pai_model(swiss_cps, method = \"gam\") #> Training 'gam' model...  # Analyze the distortion on a regular grid of points analysis_grid <- sf::st_make_grid(swiss_cps, n = c(20, 20)) %>%   sf::st_centroid() %>%   sf::st_sf()  distortion_results <- analyze_distortion(gam_model, analysis_grid) #> Calculating distortion metrics for gam model... #> Finalizing metrics from derivatives... #> Distortion analysis complete.  # Plot the learned 'log2_area_scale'. This is a symmetric metric centered # at 0, making it ideal for a diverging palette. Red areas were expanded, # blue areas were contracted. plot_distortion_surface(   distortion_results,   metric = \"log2_area_scale\",   diverging = TRUE ) #> Regular grid detected. Creating a surface plot with geom_raster(). #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead. #> Warning: Raster pixels are placed at uneven horizontal intervals and will be shifted #> ℹ Consider using `geom_tile()` instead."},{"path":"https://kvantas.github.io/mapAI/reference/train_pai_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Train a PAI Model — train_pai_model","title":"Train a PAI Model — train_pai_model","text":"Trains supervised learning analytical model define spatial transformation.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/train_pai_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Train a PAI Model — train_pai_model","text":"","code":"train_pai_model(gcp_data, method, seed = 123, ...)"},{"path":"https://kvantas.github.io/mapAI/reference/train_pai_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Train a PAI Model — train_pai_model","text":"gcp_data sf object homologous points read_gcps(). method character string specifying algorithm. One : \"lm\",\"tps\", \"gam\", \"rf\", \"helmert\". seed integer setting random seed reproducibility. ... Additional arguments passed underlying model fitting functions (mgcv::gam, stats::lm, ranger::ranger, fields::Tps).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/train_pai_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Train a PAI Model — train_pai_model","text":"trained model object class pai_model.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/train_pai_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Train a PAI Model — train_pai_model","text":"function serves factory creating transformation models. supports machine learning methods (\"lm\", \"gam\", \"rf\") learn relationship source coordinates displacement vectors, well analytical \"helmert\" method solves global similarity transformation. Important: flexible machine learning models, gam rf, require sufficient number data points produce stable reliable results. function prevent training models fewer 60 homologous points avoid overfitting. small number points, please use robust \"lm\" \"helmert\" methods.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/write_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Write a Spatial Object to a File — write_map","title":"Write a Spatial Object to a File — write_map","text":"robust user-friendly wrapper around sf::st_write save sf object, example, corrected map.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/write_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write a Spatial Object to a File — write_map","text":"","code":"write_map(map, file_path, overwrite = FALSE, ...)"},{"path":"https://kvantas.github.io/mapAI/reference/write_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write a Spatial Object to a File — write_map","text":"map sf object written file. file_path character string specifying path filename output file (e.g., \"path//my_corrected_map.shp\"). overwrite logical value. TRUE, overwrite existing file specified path. Defaults FALSE. ... Additional arguments passed directly sf::st_write (e.g., layer_options).","code":""},{"path":"https://kvantas.github.io/mapAI/reference/write_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write a Spatial Object to a File — write_map","text":"Invisibly returns input map object, allowing used pipe chain.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/write_map.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write a Spatial Object to a File — write_map","text":"function provides straightforward way save output mapAI workflow (sf object) file disk. supports file format sf::st_write can handle. function automatically infers correct driver file extension (e.g., .shp -> \"ESRI Shapefile\", .gpkg -> \"GPKG\"). safety, function defaults overwrite = FALSE, prevent accidentally overwriting existing file. Advanced users can pass additional arguments directly sf::st_write via ... parameter.","code":""},{"path":"https://kvantas.github.io/mapAI/reference/write_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write a Spatial Object to a File — write_map","text":"","code":"if (FALSE) { # \\dontrun{ # This example shows how to save data and ensure all created files are removed.  # --- 1. Create a sample sf object to write --- data(parcels) sample_map <- parcels[1:5, ]  # --- 2. Define a temporary file path --- # Using tempfile() is best practice for examples. output_path <- tempfile(fileext = \".shp\")  # --- 3. Write the map to the file --- write_map(sample_map, output_path, overwrite = TRUE)  # --- 4. Clean up ALL created files --- # A shapefile creates multiple \"sidecar\" files (.dbf, .shx, .prj, etc.). # This code finds all files with the same base name and removes them. base_name <- tools::file_path_sans_ext(output_path) files_to_remove <- list.files(dirname(base_name),                               pattern = basename(base_name),                               full.names = TRUE) file.remove(files_to_remove)  # Check that the files are gone print(list.files(dirname(output_path), pattern = basename(base_name))) } # }"}]
